#version 430

#define PI 3.1415926535897932384626433832795

layout (location = 0, rgba32f) uniform image2D map;
layout (location = 1) uniform uint seed;
layout (location = 2) uniform float delta;

layout (location = 3) uniform float speed;
layout (location = 4) uniform float turnSpeed;
layout (location = 5) uniform float sensorAngle;
layout (location = 6) uniform float sensorDistance;
layout (location = 7) uniform int sensorSize;

struct Agent
{
	vec2 position;
	float angle;
	int id;
};

layout(std430, binding = 0) buffer ssbo
{
	Agent agents[];
};

uint hash(uint state);
float random(uint state);
float sense(const Agent agent, const float sensorAngleOff);

layout (local_size_x = 16, local_size_y = 16) in;

const ivec2 imgSize = imageSize(map);
const uint id = gl_GlobalInvocationID.y * (gl_NumWorkGroups.x * gl_WorkGroupSize.x) + gl_GlobalInvocationID.x;

void main() 
{

	Agent agent = agents[id];
	const uint uniqueState = uint(agent.position.y * imgSize.x + agent.position.x) + hash(id);

	// Turn weights
	const float wForward = sense(agent, 0.0);
	const float wLeft = sense(agent, sensorAngle);
	const float wRight = sense(agent, -sensorAngle);

	const float turnStr = random(uniqueState);
	if (2.0 * wForward > wLeft + wRight)
	{	// Stay oncourse
		agents[id].angle += .0;
	}
	else if (wForward < wRight && wForward < wLeft)
	{	// Go to random turn
		agents[id].angle += (turnStr - 0.5) * 2.0 * turnSpeed * delta;
	}
	else if (wRight > wLeft)
	{	// Go right
		agents[id].angle -= turnStr * turnSpeed * delta;
	}
	else if (wLeft > wRight)
	{	// Go left
		agents[id].angle += turnStr * turnSpeed * delta;
	}

	vec2 direction = vec2(cos(agents[id].angle), sin(agents[id].angle));
	vec2 pos = agent.position + direction * delta * speed;

	if (pos.x < 0.0 || pos.x >= imgSize.x || pos.y < 0.0 || pos.y >= imgSize.y)
	{
		pos.x = min(imgSize.x - 1, max(0.0, pos.x));
		pos.y = min(imgSize.y - 1, max(0.0, pos.y));

		const float rngAngle = PI * 2.0 * random(uniqueState);
		agents[id].angle = rngAngle;
	}

	agents[id].position = pos;
	imageStore(map, ivec2(pos), vec4(1.0));
}

float sense(const Agent agent, const float sensorAngleOff)
{
	const float angle = agent.angle + sensorAngleOff;
	const vec2 direction = vec2(cos(angle), sin(angle));
	const ivec2 sensorPos = ivec2(agent.position + direction * sensorDistance);

	float weight = 0.0;
	for (int i = -sensorSize; i <= sensorSize; i++)
	{
		for (int j = -sensorSize; j <= sensorSize; j++)
		{
			const ivec2 ij = sensorPos + ivec2(i, j);
			if (ij.x >= 0 || ij.x < imgSize.x || ij.y >= 0 || ij.y < imgSize.y)
			{
				const vec3 clr = imageLoad(map, ij).rgb;
				weight += (clr.r + clr.g + clr.b) / 3.0;
			}
		}
	}
	return weight;
}

float random(uint state)
{
	return float(hash(state)) / 4294867295.0;
}

uint hash(uint state)
{
	state *= seed;
	state ^= 2747636419u;
	state *= 2654435769u;
	state ^= state >> 16;
	state *= 2654435769u;
	state ^= state >> 16;
	state *= 2654435769u;
	return state;
}